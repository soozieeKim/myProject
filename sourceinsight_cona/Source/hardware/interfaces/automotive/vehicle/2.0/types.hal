/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.automotive.vehicle@2.0;

/**
 * Enumerates supported data types for VehicleProperty.
 *
 * This is a bitwise flag that supposed to be used in VehicleProperty enum.
 */
enum VehiclePropertyType : int32_t {
    STRING         = 0x00100000,
    BOOLEAN        = 0x00200000,
    INT32          = 0x00400000,
    INT32_VEC      = 0x00410000,
    INT64          = 0x00500000,
    FLOAT          = 0x00600000,
    FLOAT_VEC      = 0x00610000,
    BYTES          = 0x00700000,

    /**
     * Any combination of scalar or vector types. The exact format must be
     * provided in the description of the property.
     */
    COMPLEX        = 0x00e00000,

    MASK           = 0x00ff0000
};

/**
 * Some properties may be associated with particular vehicle areas. For
 * example, VehicleProperty:DOOR_LOCK property must be associated with
 * particular door, thus this property must be marked with
 * VehicleArea:DOOR flag.
 *
 * Other properties may not be associated with particular vehicle area,
 * these kind of properties must have VehicleArea:GLOBAL flag.
 *
 * This is a bitwise flag that supposed to be used in VehicleProperty enum.
 */
enum VehicleArea : int32_t {
      GLOBAL       = 0x01000000,
      ZONE         = 0x02000000,
      WINDOW       = 0x03000000,
      MIRROR       = 0x04000000,
      SEAT         = 0x05000000,
      DOOR         = 0x06000000,

      MASK         = 0x0f000000,
};

/**
 * Enumerates property groups.
 *
 * This is a bitwise flag that supposed to be used in VehicleProperty enum.
 */
enum VehiclePropertyGroup : int32_t {
    /**
     * Properties declared in AOSP must have this flag.
     */
    SYSTEM         = 0x10000000,

    /**
     * Properties declared by vendors must have this flag.
     */
    VENDOR         = 0x20000000,

    MASK           = 0xf0000000,
};

/**
 * Declares all vehicle properties. VehicleProperty has a bitwise structure.
 * Each property must have:
 *   - an unique id from range 0x0100 - 0xffff
 *   - associated data type using VehiclePropertyType
 *   - property group (VehiclePropertyGroup)
 *   - vehicle area (VehicleArea)
 *
 * Vendors are allowed to extend this enum with their own properties. In this
 * case they must use VehiclePropertyGroup:VENDOR flag when property is
 * declared.
 */
enum VehicleProperty: int32_t {

    /** Undefined property. */
    INVALID = 0x00000000,

    /**
     * VIN of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_VIN= (
        0x0100
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),

    /**
     * Maker name of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_MAKE = (
        0x0101
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),

    /**
     * Model of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_MODEL = (
        0x0102
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),

    /**
     * Model year of vehicle.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:YEAR
     */
    INFO_MODEL_YEAR = (
        0x0103
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Fuel capacity of the vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:MILLILITER
     */
    INFO_FUEL_CAPACITY = (
        0x0104
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Current odometer value of the vehicle
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE | VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:KILOMETER
     */
    PERF_ODOMETER = (
        0x0204
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Speed of the vehicle
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:METER_PER_SEC
     */
    PERF_VEHICLE_SPEED = (
        0x0207
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Temperature of engine coolant
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENGINE_COOLANT_TEMP = (
        0x0301
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Temperature of engine oil
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENGINE_OIL_TEMP = (
        0x0304
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Engine rpm
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:RPM
     */
    ENGINE_RPM = (
        0x0305
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Currently selected gear
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleGear
     */
    GEAR_SELECTION = (
        0x0400
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Current gear. In non-manual case, selected gear does not necessarily
     * match the current gear.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleGear
     */
    CURRENT_GEAR = (
        0x0401
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Parking brake state.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    PARKING_BRAKE_ON = (
        0x0402
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Driving status policy.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleDrivingStatus
     */
    DRIVING_STATUS = (
        0x0404
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Warning for fuel low level.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    FUEL_LEVEL_LOW = (
        0x0405
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Night mode or not.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    NIGHT_MODE = (
        0x0407
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * State of the vehicles turn signals
     *
     * Values from VehicleTurnSignal
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    TURN_SIGNAL_STATE = (
        0x0408
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Represents ignition state
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    IGNITION_STATE = (
        0x0409
            | VehiclePropertyGroup:SYSTEM
            | VehiclePropertyType:INT32
            | VehicleArea:GLOBAL),

    /**
     * Fan speed setting
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_FAN_SPEED = (
        0x0500
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * Fan direction setting
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleHvacFanDirection
     */
    HVAC_FAN_DIRECTION = (
        0x0501
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * HVAC current temperature.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_TEMPERATURE_CURRENT = (
        0x0502
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:ZONE),

    /**
     * HVAC, target temperature set.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_TEMPERATURE_SET = (
        0x0503
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:ZONE),

    /**
     * On/off defrost
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_DEFROSTER = (
        0x0504
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:WINDOW),

    /**
     * On/off AC
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags Supported zones
     */
    HVAC_AC_ON = (
        0x0505
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off max AC
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_MAX_AC_ON = (
        0x0506
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off max defrost
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_MAX_DEFROST_ON = (
        0x0507
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off re-circulation
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_RECIRC_ON = (
        0x0508
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off dual. This must be defined per each row.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_DUAL_ON = (
        0x0509
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off automatic mode
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_AUTO_ON = (
        0x050A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * Seat temperature
     *
     * Negative values indicate cooling.
     * 0 indicates off.
     * Positive values indicate heating.
     *
     * Some vehicles may have multiple levels of heating and cooling. The
     * min/max range defines the allowable range and number of steps in each
     * direction.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_SEAT_TEMPERATURE = (
        0x050B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Side Mirror Heat
     *
     * Increase values denote higher heating levels for side mirrors.
     * 0 indicates heating is turned off.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_SIDE_MIRROR_HEAT = (
        0x050C
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Steering Wheel Temperature
     *
     * Sets the temperature for the steering wheel
     * Positive value indicates heating.
     * Negative value indicates cooling.
     * 0 indicates temperature control is off.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_STEERING_WHEEL_TEMP = (
        0x050D
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Temperature units
     *
     * Indicates whether the temperature is in Celsius, Fahrenheit, or a
     * different unit from VehicleUnit enum.
     * This parameter affects all HVAC temperatures in the system.
     *
     * IVehicle#get is not guaranteed to work if HVAC unit is off.  See
     * HVAC_POWER_ON property for details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    HVAC_TEMPERATURE_UNITS = (
        0x050E
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * Actual fan speed
     *
     * IVehicle#get is not guaranteed to work if HVAC unit is off.  See
     * HVAC_POWER_ON property for details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    HVAC_ACTUAL_FAN_SPEED_RPM = (
        0x050F
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * Fan Positions Available
     *
     * This is a bit mask of fan positions available for the zone.  Each entry in
     * vehicle_hvac_fan_direction is selected by bit position.  For instance, if
     * only the FAN_DIRECTION_FACE (0x1) and FAN_DIRECTION_DEFROST (0x4) are available,
     * then this value shall be set to 0x12.
     *
     * 0x12 = (1 << 1) | (1 << 4)
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    HVAC_FAN_DIRECTION_AVAILABLE = (
        0x0511
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * Represents power state for HVAC. Some HVAC properties must require
     * matching power to be turned on to get out of OFF state. For non-zoned
     * HVAC properties, VEHICLE_ALL_ZONE corresponds to global power state.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_string list of HVAC properties whose power is controlled by this
     *                property. Format is hexa-decimal number (0x...) separated
     *                by comma like "0x500,0x503". All zones defined in these
     *                affected properties must be available in the property.
     */
    HVAC_POWER_ON = (
        0x0510
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * Outside temperature
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENV_OUTSIDE_TEMPERATURE = (
        0x0703
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Cabin temperature
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENV_CABIN_TEMPERATURE = (
        0x0704
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Radio presets stored on the Car radio module. The data type used is int32
     * array with the following fields:
     * <ul>
     *    <li> int32Values[0]: Preset number </li>
     *    <li> int32Values[1]: Band type (see #RADIO_BAND_FM in
     *    system/core/include/system/radio.h).
     *    <li> int32Values[2]: Channel number </li>
     *    <li> int32Values[3]: Sub channel number </li>
     * </ul>
     *
     * NOTE: When getting a current preset config ONLY set preset number (i.e.
     * int32Values[0]). For setting a preset other fields are required.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags Number of presets supported
     */
    RADIO_PRESET = (
        0x0801
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Represents audio focus state of Android side. Note that car's audio
     * module must own audio focus and grant audio focus to Android side when
     * requested by Android side. The focus has both per stream characteristics
     * and global characteristics.
     *
     * Focus request (get of this property) must take the following form:
     *   int32Values[0]: VehicleAudioFocusRequest type
     *   int32Values[1]: bit flags of streams requested by this focus request.
     *                   There can be up to 32 streams.
     *   int32Values[2]: External focus state flags. For request, only flag like
     *                   VehicleAudioExtFocusFlag#PLAY_ONLY_FLAG or
     *                   VehicleAudioExtFocusFlag#MUTE_MEDIA_FLAG can be
     *                   used.
     *                   VehicleAudioExtFocusFlag#PLAY_ONLY_FLAG is for case
     *                   like radio where android side app still needs to hold
     *                   focus but playback is done outside Android.
     *                   VehicleAudioExtFocusFlag#MUTE_MEDIA_FLAG is for
     *                   muting media channel including radio.
     *                   VehicleAudioExtFocusFlag#PLAY_ONLY_FLAG can be set
     *                   even if android side releases focus (request type
     *                   REQUEST_RELEASE). In that case, audio module must
     *                   maintain mute state until user's explicit action to
     *                   play some media.
     *   int32Values[3]: Currently active audio contexts. Use combination of
     *                   flags from VehicleAudioContextFlag.
     *                   This can be used as a hint to adjust audio policy or
     *                   other policy decision.
     *                   Note that there can be multiple context active at the
     *                   same time. And android can send the same focus request
     *                   type gain due to change in audio contexts.
     * Note that each focus request can request multiple streams that is
     * expected to be used for the current request. But focus request itself
     * is global behavior as GAIN or GAIN_TRANSIENT expects all sounds played
     * by car's audio module to stop. Note that stream already allocated to
     * android before this focus request must not be affected by focus
     * request.
     *
     * Focus response (set and subscription callback for this property) must
     * take the following form:
     *   int32Values[0]: VehicleAudioFocusState type
     *   int32Values[1]: bit flags of streams allowed.
     *   int32Values[2]: External focus state: bit flags of currently active
     *                   audio focus in car side (outside Android). Active
     *                   audio focus does not necessarily mean currently
     *                   playing, but represents the state of having focus or
     *                   waiting for focus (pause state).
     *                   One or combination of flags from
     *                   VehicleAudioExtFocusFlag.
     *                   0 means no active audio focus holder outside Android.
     *                   The state must have following values for each
     *                   VehicleAudioFocusState:
     *                   GAIN: 0 or VehicleAudioExtFocusFlag#PLAY_ONLY_FLAG
     *                       when radio is active in Android side.
     *                   GAIN_TRANSIENT: 0. Can be
     *                       VehicleAudioExtFocusFlag#PERMANENT_FLAG or
     *                       VehicleAudioExtFocusFlag#TRANSIENT_FLAG if android
     *                       side has requested
     *                       REQUEST_GAIN_TRANSIENT_MAY_DUCK and car side is
     *                       ducking.
     *                   LOSS: 0 when no focus is audio is active in car side.
     *                       VehicleAudioExtFocusFlag#PERMANENT_FLAG when car
     *                       side is playing something permanent.
     *                   LOSS_TRANSIENT: always must be
     *                       VehicleAudioExtFocusFlag#PERMANENT_FLAG
     *   int32Values[3]: context requested by android side when responding to
     *                   focus request. When car side is taking focus away,
     *                   this must be zero.
     *
     * A focus response must be sent per each focus request even if there is
     * no change in focus state. This can happen in case like focus request
     * only involving context change where android side still needs matching
     * focus response to confirm that audio module has made necessary changes.
     *
     * If car does not support AUDIO_FOCUS, focus is assumed to be granted
     * always.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    AUDIO_FOCUS = (
        0x0900
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * A property to allow external component to control audio focus. Depending on
     * H/W architecture, audio HAL may need to control audio focus while vehicle
     * HAL is still interacting with upper layer. In such case, audio HAL may set
     * this property and vehicle HAL may use this property value to decide
     * response sent through AUDIO_FOCUS property.
     * Data format is the same as AUDIO_FOCUS property.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    AUDIO_FOCUS_EXT_SYNC = (
        0x0910
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to control audio volume of each audio context.
     *
     * VehiclePropConfig
     *   configArray[0] : bit flags of all supported audio contexts from
     *                    VehicleAudioContextFlag. If this is 0, audio volume is
     *                    controlled per physical stream.
     *   configArray[1] : flags defined in VehicleAudioVolumeCapabilityFlag to
     *                    represent audio module's capability.
     *   configArray[2..3] : reserved
     *   configArray[4..N+3] : maximum values for each audio context, where N is
     *                         the number of audio contexts provided in
     *                         configArray[0], minimum value is always 0 which
     *                         indicates mute state.
     *
     * Data type looks like:
     *   int32Values[0] : stream context as defined in VehicleAudioContextFlag.
     *                    If only physical stream is supported
     *                    (configArray[0] == 0), this must represent physical
     *                    stream number.
     *   int32Values[1] : volume level, valid range is 0 (mute) to max level
     *                    defined in the config.
     *   int32Values[2] : One of VehicleAudioVolumeState.
     *
     * This property requires per stream based get. HAL implementation must
     * check stream number in get call to return the right volume.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags all audio contexts supported.
     */
    AUDIO_VOLUME = (
        0x0901
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to allow audio volume sync from external components like audio HAL.
     * Some vehicle HAL implementation may get volume control from audio HAL and in such
     * case, setting AUDIO_VOLUME_EXT_SYNC property may trigger event in AUDIO_VOLUME property.
     * Data format for this property is the same as AUDIO_VOLUME property.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags all audio contexts supported.
     */
    AUDIO_VOLUME_EXT_SYNC = (
        0x0911
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property for handling volume limit set by user. This limits maximum
     * volume that can be set per each context or physical stream.
     *
     * VehiclePropConfig
     *   configArray[0] : bit flags of all supported audio contexts. If this is
     *                    0, audio volume is controlled per physical stream.
     *   configArray[1] : flags defined in VehicleAudioVolumeCapabilityFlag
     *                    to represent audio module's capability.
     *
     * Data type looks like:
     *   int32Values[0] : stream context as defined in VehicleAudioFocusFlag.
     *                    If only physical stream is supported
     *                    (configArray[0] == 0), this must represent physical
     *                    stream number.
     *   int32Values[1] : maximum volume set to the stream. If there is no
     *                    restriction, this value must be  bigger than
     *                    AUDIO_VOLUME's max value.
     *
     * If car does not support this feature, this property must not be
     * populated by HAL.
     * This property requires per stream based get. HAL implementation must
     * check stream number in get call to return the right volume.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags all audio contexts supported.
     */
    AUDIO_VOLUME_LIMIT = (
        0x0902
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to share audio routing policy of android side. This property is
     * set at the beginning to pass audio policy in android side down to
     * vehicle HAL and car audio module.
     * This can be used as a hint to adjust audio policy or other policy
     * decision.
     *
     *   int32Values[0] : audio stream where the audio for the application
     *                    context must be routed by default. Note that this is
     *                    the default setting from system, but each app may
     *                    still use different audio stream for whatever reason.
     *   int32Values[1] : All audio contexts that must be sent through the
     *                     physical stream. Flag is defined in
     *                     VehicleAudioFocusFlag.

     * Setting of this property must be done for all available physical streams
     * based on audio H/W variant information acquired from AUDIO_HW_VARIANT
     * property.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    AUDIO_ROUTING_POLICY = (
        0x0903
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to return audio H/W variant type used in this car. This allows
     * android side to support different audio policy based on H/W variant used.
     * Note that other components like CarService may need overlay update to
     * support additional variants. If this property does not
     * exist, default audio policy must be used.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @config_flags Additional info on audio H/W. Must use
     *               VehicleAudioHwVariantConfigFlag for this.
     */
    AUDIO_HW_VARIANT = (
        0x0904
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Property to pass hint on external audio routing. When android side
     * request focus with VehicleAudioExtFocusflag, this
     * property must be set before setting AUDIO_FOCUS property as a hint for
     * external audio source routing.
     * Note that setting this property alone must not trigger any change.
     * Audio routing must be changed only when AUDIO_FOCUS property is set.
     * Note that this property allows passing custom value as long as it is
     * defined in VehiclePropConfig#configString. This allows supporting
     * non-standard routing options through this property.
     * It is recommended to use separate name space for custom property to
     * prevent conflict in future android releases.
     * Enabling each external routing option is done by enabling each bit flag
     * for the routing.
     * This property can support up to 128 external routings.
     * To give full flexibility, there is no standard definition for each bit
     * flag and assigning each big flag to specific routing type is decided by
     * VehiclePropConfig#configString.  VehiclePropConfig#configString has
     * format of each entry separated by ',' and each entry has format of
     * bitFlagPositon:typeString[:physicalStreamNumber].
     *  bitFlagPosition: represents which big flag will be set to enable this
     *  routing. 0 means
     *    LSB in int32Values[0]. 31 will be MSB in int32Values[0]. 127 will MSB
     *    in int32Values[3].
     *  typeString: string representation of external routing. Some types are
     *    already defined in AUDIO_EXT_ROUTING_SOURCE_* and use them first
     *    before adding something custom. Applications will find each routing
     *    using this string.
     *  physicalStreamNumber: This part is optional and represents physical
     *    stream to android which will be disabled when this routing is enabled.
     *    If not specified, this routing must not affect physical streams to
     *    android.
     * As an example, let's assume a system with two physical streams, 0 for
     * media and 1 for nav guidance. And let's assume external routing option
     * of am fm radio, external navigation guidance, satellite radio, and one
     * custom. Let's assume that radio and satellite replaces physical stream 0
     * and external navigation replaces physical stream 1. And bit flag will be
     * assigned in the order listed above. This configuration will look like
     * this in config_string:
     *  "0:RADIO_AM_FM:0,1:EXT_NAV_GUIDANCE:1,2:RADIO_SATELLITE:0,3:com.test.SOMETHING_CUSTOM"
     * When android requests RADIO_AM_FM, int32Values[0] will be set to 0x1.
     * When android requests RADIO_SATELLITE + EXT_NAV_GUIDANCE, int32Values[0]
     * will be set to 0x2|0x4.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_string List of all avaiable external source in the system.
     */
    AUDIO_EXT_ROUTING_HINT = (
        0x0905
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Represents state of audio stream. Audio HAL should set this when a stream is starting or
     * ending. Car service can request focus for audio played without focus. If such feature
     * is not required, this property does not need to be implemented.
     * Car service only monitors setting of this property. It is up to each vehicle HAL
     * implementation to add necessary action but default implementation will be doing nothing on
     * this propery's set from audio HAL.
     * Actual streaming of data should be done only after getting focus for the given stream from
     * car audio module. Focus can be already granted when stream is started. Focus state can be
     * monitored by monitoring AUDIO_FOCUS property. If car does not support
     * AUDIO_FOCUS property, there is no need to monitor focus as focus is assumed to be
     * granted always.
     * Data has the following format:
     *   int32_array[0] : vehicle_audio_stream_state, 0: stopped, 1: started
     *   int32_array[1] : stream number like 0, 1, 2, ...
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    AUDIO_STREAM_STATE  = (
        0x0906
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to control car specific audio parameters. Each parameter is defined as string key-
     * value pair.
     * set and event notification can pass multiple parameters using the
     * following format:
     *   key1=value1;key2=value2;...
     * get call can request multiple parameters using the following format:
     *   key1;key2;...
     * Response for get call has the same format as set.
     *
     * VehiclePropConfig
     *   configString: give list of all supported keys with ; as separator. For example:
     *     key1;key2;...
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    AUDIO_PARAMETERS = (
        0x907
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),

    /**
     * Property to control power state of application processor
     *
     * It is assumed that AP's power state is controller by separate power
     * controller.
     *
     * For configuration information, VehiclePropConfig.configFlags can
     * have bit flag combining values in VehicleApPowerStateConfigFlag.
     *
     * Value format for IVehicle#get / IVehicle#subscribe:
     *   int32Values[0] : vehicle_ap_power_state_type
     *   int32Values[1] : additional parameter relevant for each state,
     *                    0 if not used.
     * Value format for IVehicle#set:
     *   int32Values[0] : vehicle_ap_power_state_set_type
     *   int32Values[1] : additional parameter relevant for each request. should be 0 if not used.
     *
     * @change_mode VEHICLE_PROP_CHANGE_MODE_ON_CHANGE
     * @access VEHICLE_PROP_ACCESS_READ_WRITE
     */
    AP_POWER_STATE = (
        0x0A00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to represent brightness of the display. Some cars have single
     * control for the brightness of all displays and this property is to share
     * change in that control.
     *
     * If this is writable, android side can set this value when user changes
     * display brightness from Settings. If this is read only, user may still
     * change display brightness from Settings, but that will not be reflected
     * to other displays.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DISPLAY_BRIGHTNESS = (
        0x0A01
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Property to report bootup reason for the current power on. This is a
     * static property that will not change for the whole duration until power
     * off. For example, even if user presses power on button after automatic
     * power on with door unlock, bootup reason must stay with
     * VehicleApPowerBootupReason#USER_UNLOCK.
     *
     * int32Values[0] must be VehicleApPowerBootupReason.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
    */
    AP_POWER_BOOTUP_REASON = (
        0x0A02
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Property to feed H/W input events to android
     *
     * int32Values[0] : action defined by VehicleHwKeyInputAction
     * int32Values[1] : key code, must use standard android key code
     * int32Values[2] : target display defined in VehicleDisplay. Events not
     *                  tied to specific display must be sent to
     *                  VehicleDisplay#MAIN.
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @config_flags
     */
    HW_KEY_INPUT = (
        0x0A10
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to define instrument cluster information.
     * For VehicleInstrumentClusterType:EXTERNAL_DISPLAY:
     *  READ:
     *   int32Values[0] : The current screen mode index. Screen mode is defined
     *                    as a configuration in car service and represents
     *                    which area of screen is renderable.
     *   int32Values[1] : Android can render to instrument cluster (=1) or
     *                    not(=0). When this is 0, instrument cluster may be
     *                    rendering some information in the area allocated for
     *                    android and android side rendering is invisible.
     *  WRITE from android:
     *   int32Values[0] : Preferred mode for android side. Depending on the app
     *                    rendering to instrument cluster, preferred mode can
     *                    change. Instrument cluster still needs to send
     *                    event with new mode to trigger actual mode change.
     *   int32Values[1] : The current app context relevant for instrument
     *                    cluster. Use the same flag with VehicleAudioFocusFlag
     *                    but this context represents active apps, not
     *                    active audio. Instrument cluster side may change mode
     *                    depending on the currently active contexts.
     *  When system boots up, Android side will write {0, 0, 0, 0} when it is
     *  ready to render to instrument cluster. Before this message, rendering
     *  from android must not be visible in the cluster.
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @configArray 0:VehicleInstrumentClusterType 1:hw type
     */
    INSTRUMENT_CLUSTER_INFO = (
        0x0A20
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Current date and time, encoded as Unix time.
     * This value denotes the number of seconds that have elapsed since
     * 1/1/1970.
     *
     * @change_mode VehiclePropertyChangeMode:ON_SET
     * @access VehiclePropertyAccess:READ_WRITE
     * @unit VehicleUnit:SECS
     */
    UNIX_TIME = (
        0x0A30
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT64
        | VehicleArea:GLOBAL),

    /**
     * Current time only.
     * Some vehicles may not keep track of date.  This property only affects
     * the current time, in seconds during the day.  Thus, the max value for
     * this parameter is 86,400 (24 * 60 * 60)
     *
     * @change_mode VehiclePropertyChangeMode:ON_SET
     * @access VehiclePropertyAccess:READ_WRITE
     * @unit VehicleUnit:SECS
     */
    CURRENT_TIME_IN_SECONDS = (
        0x0A31
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Door position
     *
     * This is an integer in case a door may be set to a particular position.
     * Max value indicates fully open, min value (0) indicates fully closed.
     *
     * Some vehicles (minivans) can open the door electronically.  Hence, the
     * ability to write this property.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_POS = (
        0x0B00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:DOOR),

    /**
     * Door move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_MOVE = (
        0x0B01
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:DOOR),

    /**
     * Door lock
     *
     * 'true' indicates door is locked
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_LOCK = (
        0x0B02
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:DOOR),

    /**
     * Mirror Z Position
     *
     * Positive value indicates tilt upwards, negative value is downwards
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Z_POS = (
        0x0B40
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Z Move
     *
     * Positive value indicates tilt upwards, negative value is downwards
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Z_MOVE = (
        0x0B41
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Y Position
     *
     * Positive value indicate tilt right, negative value is left
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Y_POS = (
        0x0B42
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Y Move
     *
     * Positive value indicate tilt right, negative value is left
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Y_MOVE = (
        0x0B43
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Lock
     *
     * True indicates mirror positions are locked and not changeable
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_LOCK = (
        0x0B44
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Mirror Fold
     *
     * True indicates mirrors are folded
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_FOLD = (
        0x0B45
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Seat memory select
     *
     * This parameter selects the memory preset to use to select the seat
     * position. The minValue is always 0, and the maxValue determines the
     * number of seat positions available.
     *
     * For instance, if the driver's seat has 3 memory presets, the maxValue
     * will be 3. When the user wants to select a preset, the desired preset
     * number (1, 2, or 3) is set.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    SEAT_MEMORY_SELECT = (
        0x0B80
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat memory set
     *
     * This setting allows the user to save the current seat position settings
     * into the selected preset slot.  The maxValue for each seat position
     * shall match the maxValue for SEAT_MEMORY_SELECT.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    SEAT_MEMORY_SET = (
        0x0B81
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seatbelt buckled
     *
     * True indicates belt is buckled.
     *
     * Write access indicates automatic seat buckling capabilities.  There are
     * no known cars at this time, but you never know...
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_BUCKLED = (
        0x0B82
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),

    /**
     * Seatbelt height position
     *
     * Adjusts the shoulder belt anchor point.
     * Max value indicates highest position
     * Min value indicates lowest position
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_HEIGHT_POS = (
        0x0B83
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seatbelt height move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_HEIGHT_MOVE = (
        0x0B84
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat fore/aft position
     *
     * Sets the seat position forward (closer to steering wheel) and backwards.
     * Max value indicates closest to wheel, min value indicates most rearward
     * position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_FORE_AFT_POS = (
        0x0B85
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat fore/aft move
     *
     * Moves the seat position forward and aft.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_FORE_AFT_MOVE = (
        0x0B86
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 1 position
     *
     * Backrest angle 1 is the actuator closest to the bottom of the seat.
     * Max value indicates angling forward towards the steering wheel.
     * Min value indicates full recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_1_POS = (
        0x0B87
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 1 move
     *
     * Moves the backrest forward or recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_1_MOVE = (
        0x0B88
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 2 position
     *
     * Backrest angle 2 is the next actuator up from the bottom of the seat.
     * Max value indicates angling forward towards the steering wheel.
     * Min value indicates full recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_2_POS = (
        0x0B89
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 2 move
     *
     * Moves the backrest forward or recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_2_MOVE = (
        0x0B8A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat height position
     *
     * Sets the seat height.
     * Max value indicates highest position.
     * Min value indicates lowest position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEIGHT_POS = (
        0x0B8B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat height move
     *
     * Moves the seat height.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEIGHT_MOVE = (
        0x0B8C
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat depth position
     *
     * Sets the seat depth, distance from back rest to front edge of seat.
     * Max value indicates longest depth position.
     * Min value indicates shortest position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_DEPTH_POS = (
        0x0B8D
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat depth move
     *
     * Adjusts the seat depth.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_DEPTH_MOVE = (
        0x0B8E
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat tilt position
     *
     * Sets the seat tilt.
     * Max value indicates front edge of seat higher than back edge.
     * Min value indicates front edge of seat lower than back edge.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_TILT_POS = (
        0x0B8F
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat tilt move
     *
     * Tilts the seat.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_TILT_MOVE = (
        0x0B90
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumber fore/aft position
     *
     * Pushes the lumbar support forward and backwards
     * Max value indicates most forward position.
     * Min value indicates most rearward position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_FORE_AFT_POS = (
        0x0B91
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumbar fore/aft move
     *
     * Adjusts the lumbar support.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_FORE_AFT_MOVE = (
        0x0B92
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumbar side support position
     *
     * Sets the amount of lateral lumbar support.
     * Max value indicates widest lumbar setting (i.e. least support)
     * Min value indicates thinnest lumbar setting.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_SIDE_SUPPORT_POS = (
        0x0B93
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumbar side support move
     *
     * Adjusts the amount of lateral lumbar support.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_SIDE_SUPPORT_MOVE = (
        0x0B94
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest height position
     *
     * Sets the headrest height.
     * Max value indicates tallest setting.
     * Min value indicates shortest setting.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_HEIGHT_POS = (
        0x0B95
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Headrest height move
     *
     * Moves the headrest up and down.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_HEIGHT_MOVE = (
        0x0B96
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest angle position
     *
     * Sets the angle of the headrest.
     * Max value indicates most upright angle.
     * Min value indicates shallowest headrest angle.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_ANGLE_POS = (
        0x0B97
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest angle move
     *
     * Adjusts the angle of the headrest
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_ANGLE_MOVE = (
        0x0B98
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest fore/aft position
     *
     * Adjusts the headrest forwards and backwards.
     * Max value indicates position closest to front of car.
     * Min value indicates position closest to rear of car.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_FORE_AFT_POS = (
        0x0B99
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest fore/aft move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_FORE_AFT_MOVE = (
        0x0B9A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Window Position
     *
     * Max = window up / closed
     * Min = window down / open
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_POS = (
        0x0BC0
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Window Move
     *
     * Max = window up / closed
     * Min = window down / open
     * Magnitude denotes relative speed.  I.e. +2 is faster than +1 in raising
     * the window.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_MOVE = (
        0x0BC1
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Window Vent Position
     *
     * This feature is used to control the vent feature on a sunroof.
     *
     * Max = vent open
     * Min = vent closed
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_VENT_POS = (
        0x0BC2
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Window Vent Move
     *
     * This feature is used to control the vent feature on a sunroof.
     *
     * Max = vent open
     * Min = vent closed
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_VENT_MOVE = (
        0x0BC3
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Window Lock
     *
     * True indicates windows are locked and can't be moved.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_LOCK = (
        0x0BC4
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
};

/**
 * Bit flags for fan direction
 */
enum VehicleHvacFanDirection : int32_t {
  FACE = 0x1,
  FLOOR = 0x2,
  FACE_AND_FLOOR = 0x3,
  DEFROST = 0x4,
  DEFROST_AND_FLOOR = 0x5,
};

/**
 * Constants relevant to radio.
 */
enum VehicleRadioConstants : int32_t {
  /** Minimum value for the radio preset */
  VEHICLE_RADIO_PRESET_MIN_VALUE = 1,
};

enum VehicleAudioFocusRequest : int32_t {
  REQUEST_GAIN = 0x1,
  REQUEST_GAIN_TRANSIENT = 0x2,
  REQUEST_GAIN_TRANSIENT_MAY_DUCK = 0x3,
  /**
   * This is for the case where android side plays sound like UI feedback
   * and car side does not need to duck existing playback as long as
   * requested stream is available.
   */
  REQUEST_GAIN_TRANSIENT_NO_DUCK = 0x4,
  REQUEST_RELEASE = 0x5,

};

enum VehicleAudioFocusState : int32_t {
  /**
   * Android side has permanent focus and can play allowed streams.
   */
  STATE_GAIN = 0x1,

  /**
   * Android side has transient focus and can play allowed streams.
   */
  STATE_GAIN_TRANSIENT = 0x2,

  /**
   * Car audio module is playing guidance kind of sound outside Android.
   * Android side can still play through allowed streams with ducking.
   */
  STATE_LOSS_TRANSIENT_CAN_DUCK = 0x3,

  /**
   * Car audio module is playing transient sound outside Android. Android side
   * must stop playing any sounds.
   */
  STATE_LOSS_TRANSIENT = 0x4,

  /**
   * Android side has lost focus and cannot play any sound.
   */
  STATE_LOSS = 0x5,

  /**
   * car audio module is playing safety critical sound, and Android side cannot
   * request focus until the current state is finished. car audio module
   * restore it to the previous state when it can allow Android to play.
   */
  STATE_LOSS_TRANSIENT_EXLCUSIVE = 0x6,

};

/**
 * Flags to represent multiple streams by combining these.
 */
enum VehicleAudioStreamFlag : int32_t {
  STREAM0_FLAG = (0x1 << 0),
  STREAM1_FLAG = (0x1 << 1),
  STREAM2_FLAG = (0x1 << 2),
};

/**
 * Represents stream number (always 0 to N -1 where N is max number of streams).
 * Can be used for audio related property expecting one stream.
 */
enum VehicleAudioStream : int32_t {
  STREAM0 = 0,
  STREAM1 = 1,
};

/**
 * Flag to represent external focus state (outside Android).
 */
enum VehicleAudioExtFocusFlag : int32_t {
  /**
   * No external focus holder.
   */
  NONE_FLAG = 0x0,

  /**
   * Car side (outside Android) has component holding GAIN kind of focus state.
   */
  PERMANENT_FLAG = 0x1,

  /**
   * Car side (outside Android) has component holding GAIN_TRANSIENT kind of
   * focus state.
   */
  TRANSIENT_FLAG = 0x2,

  /**
   * Car side is expected to play something while focus is held by Android side.
   * One example can be radio attached in car side. But Android's radio app
   * still must have focus, and Android side must be in GAIN state, but
   * media stream will not be allocated to Android side and car side can play
   * radio any time while this flag is active.
   */
  PLAY_ONLY_FLAG = 0x4,

  /**
   * Car side must mute any media including radio. This can be used with any
   * focus request including GAIN* and RELEASE.
   */
  MUTE_MEDIA_FLAG = 0x8,
};

/**
 * Index in int32Values for VehicleProperty#AUDIO_FOCUS property.
 */
enum VehicleAudioFocusIndex : int32_t {
  FOCUS = 0,
  STREAMS = 1,
  EXTERNAL_FOCUS_STATE = 2,
  AUDIO_CONTEXTS = 3,
};

/**
 * Flags to tell the current audio context.
 */
enum VehicleAudioContextFlag : int32_t {
  /** Music playback is currently active. */
  MUSIC_FLAG = 0x1,

  /** Navigation is currently running. */
  NAVIGATION_FLAG = 0x2,

  /** Voice command session is currently running. */
  VOICE_COMMAND_FLAG = 0x4,

  /** Voice call is currently active. */
  CALL_FLAG = 0x8,

  /**
   * Alarm is active.
   * This must be only used in VehicleProperty#AUDIO_ROUTING_POLICY.
   */
  ALARM_FLAG = 0x10,

  /**
   * Notification sound is active.
   * This must be only used in VehicleProperty#AUDIO_ROUTING_POLICY.
   */
  NOTIFICATION_FLAG = 0x20,

  /**
   * Context unknown. Only used for VehicleProperty#AUDIO_ROUTING_POLICY to
   * represent default stream for unknown contents.
   */
  UNKNOWN_FLAG = 0x40,

  /** Safety alert / warning is played. */
  SAFETY_ALERT_FLAG = 0x80,

  /** CD / DVD kind of audio is played */
  CD_ROM_FLAG = 0x100,

  /** Aux audio input is played */
  AUX_AUDIO_FLAG = 0x200,

  /** system sound like UI feedback */
  SYSTEM_SOUND_FLAG = 0x400,

  /** Radio is played */
  RADIO_FLAG = 0x800,

  /** Ext source is played. This is for tagging generic ext sources. */
  EXT_SOURCE_FLAG = 0x1000,
};

/**
 * flags to represent capability of audio volume property.
 * used in configArray[1] of VehiclePropConfig.
 */
enum VehicleAudioVolumeCapabilityFlag : int32_t {
  /**
   * External audio module or vehicle hal has persistent storage
   * to keep the volume level. This must be set only when per context
   * volume level is supported. When this is set, audio volume level per
   * each context will be retrieved from the property when system starts up.
   * And external audio module is also expected to adjust volume automatically
   * whenever there is an audio context change.
   * When this flag is not set, android side will assume that there is no
   * persistent storage and stored value in android side will be used to
   * initialize the volume level. And android side will set volume level
   * of each physical streams whenever there is an audio context change.
   */
  PERSISTENT_STORAGE = 0x1,

  /**
   * When this flag is set, the H/W can support only single master volume for
   * all streams.
   * There is no way to set volume level differently per each stream or context.
   */
  MASTER_VOLUME_ONLY = 0x2,
};

/**
 * enum to represent audio volume state.
 */
enum VehicleAudioVolumeState : int32_t {
  STATE_OK = 0,

  /**
   * Audio volume has reached volume limit set in
   * VehicleProperty#AUDIO_VOLUME_LIMIT and user's request to increase volume
   * further is not allowed.
   */
  LIMIT_REACHED = 1,
};

/**
 * Index in int32Values for VehicleProperty#AUDIO_VOLUME property.
 */
enum VehicleAudioVolumeIndex : int32_t {
  INDEX_STREAM = 0,
  INDEX_VOLUME = 1,
  INDEX_STATE = 2,
};

/**
 * Index in int32Values for VehicleProperty#AUDIO_VOLUME_LIMIT property.
 */
enum VehicleAudioVolumeLimitIndex : int32_t {
  STREAM = 0,
  MAX_VOLUME = 1,
};

/**
 * Index in int32Values for VehicleProperty#AUDIO_ROUTING_POLICY property.
 */
enum VehicleAudioRoutingPolicyIndex : int32_t {
  STREAM = 0,
  CONTEXTS = 1,
};

/**
 * Flag to be used in VehiclePropConfig#configFlags for
 * VehicleProperty#AUDIO_HW_VARIANT.
 */
enum VehicleAudioHwVariantConfigFlag : int32_t {
  /**
   * Flag to tell that radio is internal to android and radio must
   * be treated like other android stream like media.
   * When this flag is not set or AUDIO_HW_VARIANT does not exist,
   * radio is treated as external module. This brins some delta in audio focus
   * handling as well.
   */
  INTERNAL_RADIO_FLAG = 0x1,
};

enum VehicleApPowerStateConfigFlag : int32_t /* NOTE: type is guessed */ {
  /**
   * AP can enter deep sleep state. If not set, AP will always shutdown from
   * VehicleApPowerState#SHUTDOWN_PREPARE power state.
   */
  ENABLE_DEEP_SLEEP_FLAG = 0x1,

  /**
   * The power controller can power on AP from off state after timeout
   * specified in VehicleApPowerSet VEHICLE_AP_POWER_SET_SHUTDOWN_READY message.
   */
  CONFIG_SUPPORT_TIMER_POWER_ON_FLAG = 0x2,
};

enum VehicleApPowerState : int32_t /* NOTE: type is guessed */ {
  /** vehicle HAL will never publish this state to AP */
  OFF = 0,

  /** vehicle HAL will never publish this state to AP */
  DEEP_SLEEP = 1,

  /** AP is on but display must be off. */
  ON_DISP_OFF = 2,

  /** AP is on with display on. This state allows full user interaction. */
  ON_FULL = 3,

  /**
   * The power controller has requested AP to shutdown. AP can either enter
   * sleep state or start full shutdown. AP can also request postponing
   * shutdown by sending VehicleApPowerSetState#SHUTDOWN_POSTPONE message. The
   * power controller must change power state to this state to shutdown
   * system.
   *
   * int32Values[1] : one of enum_vehicle_ap_power_state_shutdown_param_type
   */
  SHUTDOWN_PREPARE = 4,
};

enum VehicleApPowerStateShutdownParam : int32_t {
  /** AP must shutdown immediately. Postponing is not allowed. */
  SHUTDOWN_IMMEDIATELY = 1,

  /** AP can enter deep sleep instead of shutting down completely. */
  CAN_SLEEP = 2,

  /** AP can only shutdown with postponing allowed. */
  SHUTDOWN_ONLY = 3,
};

enum VehicleApPowerSetState : int32_t /* NOTE: type is guessed */ {
  /**
   * AP has finished boot up, and can start shutdown if requested by power
   * controller.
   */
  BOOT_COMPLETE = 0x1,

  /**
   * AP is entering deep sleep state. How this state is implemented may vary
   * depending on each H/W, but AP's power must be kept in this state.
   */
  DEEP_SLEEP_ENTRY = 0x2,

  /**
   * AP is exiting from deep sleep state, and is in
   * VehicleApPowerState#SHUTDOWN_PREPARE state.
   * The power controller may change state to other ON states based on the
   * current state.
   */
  DEEP_SLEEP_EXIT = 0x3,

  /**
   * int32Values[1]: Time to postpone shutdown in ms. Maximum value can be
   *                 5000 ms.
   *                 If AP needs more time, it will send another POSTPONE
   *                 message before the previous one expires.
   */
  SHUTDOWN_POSTPONE = 0x4,

  /**
   * AP is starting shutting down. When system completes shutdown, everything
   * will stop in AP as kernel will stop all other contexts. It is
   * responsibility of vehicle HAL or lower level to synchronize that state
   * with external power controller. As an example, some kind of ping
   * with timeout in power controller can be a solution.
   *
   * int32Values[1]: Time to turn on AP in secs. Power controller may turn on
   *                 AP after specified time so that AP can run tasks like
   *                 update. If it is set to 0, there is no wake up, and power
   *                 controller may not necessarily support wake-up. If power
   *                 controller turns on AP due to timer, it must start with
   *                 VehicleApPowerState#ON_DISP_OFF state, and after
   *                 receiving VehicleApPowerSetState#BOOT_COMPLETE, it shall
   *                 do state transition to
   *                 VehicleApPowerState#SHUTDOWN_PREPARE.
   */
  SHUTDOWN_START = 0x5,

  /**
   * User has requested to turn off headunit's display, which is detected in
   * android side.
   * The power controller may change the power state to
   * VehicleApPowerState#ON_DISP_OFF.
   */
  DISPLAY_OFF = 0x6,

  /**
   * User has requested to turn on headunit's display, most probably from power
   * key input which is attached to headunit. The power controller may change
   * the power state to VehicleApPowerState#ON_FULL.
   */
  DISPLAY_ON = 0x7,
};

/**
 * Index in int32Values for VehicleProperty#AP_POWER_STATE property.
 */
enum VehicleApPowerStateIndex : int32_t {
  STATE = 0,
  ADDITIONAL = 1,
};

/**
 * Enum to represent bootup reason.
 */
enum VehicleApPowerBootupReason : int32_t {
  /**
   * Power on due to user's pressing of power key or rotating of ignition
   * switch.
   */
  USER_POWER_ON = 0,

  /**
   * Automatic power on triggered by door unlock or any other kind of automatic
   * user detection.
   */
  USER_UNLOCK = 1,

  /**
   * Automatic power on triggered by timer. This only happens when AP has asked
   * wake-up after
   * certain time through time specified in
   * VehicleApPowerSetState#SHUTDOWN_START.
   */
  TIMER = 2,
};

enum VehicleHwKeyInputAction : int32_t {
  /** Key down */
  ACTION_DOWN = 0,

  /** Key up */
  ACTION_UP = 1,
};

enum VehicleDisplay : int32_t {
  /** center console */
  MAIN = 0,

  INSTRUMENT_CLUSTER = 1,
};

/**
 * Represents instrument cluster type available in system
 */
enum VehicleInstrumentClusterType : int32_t {
  /** Android has no access to instument cluster */
  NONE = 0,

  /**
   * Instrument cluster can communicate through vehicle hal with additional
   * properties to exchange meta-data
   */
  HAL_INTERFACE = 1,

  /**
   * Instrument cluster is external display where android can render contents
   */
  EXTERNAL_DISPLAY = 2,
};

/**
 * Units used for int or float type with no attached enum types.
 */
enum VehicleUnit : int32_t {
    SHOULD_NOT_USE = 0x000,

    METER_PER_SEC  = 0x01,
    RPM            = 0x02,
    HERTZ          = 0x03,
    PERCENTILE     = 0x10,
    MILLIMETER     = 0x20,
    METER          = 0x21,
    KILOMETER      = 0x23,
    CELSIUS        = 0x30,
    FAHRENHEIT     = 0x31,
    KELVIN         = 0x32,
    MILLILITER     = 0x40,
    NANO_SECS      = 0x50,
    SECS           = 0x53,
    YEAR           = 0x59,
};

  /**
   * This describes how value of property can change.
   */
enum VehiclePropertyChangeMode : int32_t {
  /**
   * Property of this type must never be changed. Subscription is not supported
   * for these properties.
   */
  STATIC = 0x00,

  /**
   * Property of this type must be reported when there is a change.
   * IVehicle#get call must return the current value.
   * Set operation for this property is assumed to be asynchronous. When the
   * property is read (using IVehicle#get) after IVehicle#set, it may still
   * return old value until underlying H/W backing this property has actually
   * changed the state. Once state is changed, the property must dispatch
   * changed value as event.
   */
  ON_CHANGE = 0x01,

  /**
   * Property of this type change continuously and requires fixed rate of
   * sampling to retrieve the data.
   */
  CONTINUOUS = 0x02,

  /**
   * Property of this type may be polled to get the current value.
   */
  POLL = 0x03,

  /**
   * This is for property where change event must be sent only when the
   * value is set from external component. Normal value change must not trigger
   * event. For example, clock property can send change event only when it is
   * set, outside android, for case like user setting time or time getting
   * update. There is no need to send it per every value change.
   */
  ON_SET = 0x04,
};

/**
 * Property config defines the capabilities of it. User of the API
 * must first get the property config to understand the output from get()
 * commands and also to ensure that set() or events commands are in sync with
 * the expected output.
 */
enum VehiclePropertyAccess : int32_t {
  NONE = 0x00,

  READ = 0x01,
  WRITE = 0x02,
  READ_WRITE = 0x03,
};

/**
 * Car states.
 *
 * The driving states determine what features of the UI will be accessible.
 */
enum VehicleDrivingStatus : int32_t {
  UNRESTRICTED = 0x00,
  NO_VIDEO = 0x01,
  NO_KEYBOARD_INPUT = 0x02,
  NO_VOICE_INPUT = 0x04,
  NO_CONFIG = 0x08,
  LIMIT_MESSAGE_LEN = 0x10,
};

/**
 * Various gears which can be selected by user and chosen in system.
 */
enum VehicleGear: int32_t {
  GEAR_NEUTRAL = 0x0001,
  GEAR_REVERSE = 0x0002,
  GEAR_PARK = 0x0004,
  GEAR_DRIVE = 0x0008,
  GEAR_LOW = 0x0010,
  GEAR_1 = 0x0010,
  GEAR_2 = 0x0020,
  GEAR_3 = 0x0040,
  GEAR_4 = 0x0080,
  GEAR_5 = 0x0100,
  GEAR_6 = 0x0200,
  GEAR_7 = 0x0400,
  GEAR_8 = 0x0800,
  GEAR_9 = 0x1000,
};

/**
 * Various zones in the car.
 *
 * Zones are used for Air Conditioning purposes and divide the car into physical
 * area zones.
 */
enum VehicleAreaZone : int32_t {
  ROW_1_LEFT = 0x00000001,
  ROW_1_CENTER = 0x00000002,
  ROW_1_RIGHT = 0x00000004,
  ROW_1 = 0x00000008,
  ROW_2_LEFT = 0x00000010,
  ROW_2_CENTER = 0x00000020,
  ROW_2_RIGHT = 0x00000040,
  ROW_2 = 0x00000080,
  ROW_3_LEFT = 0x00000100,
  ROW_3_CENTER = 0x00000200,
  ROW_3_RIGHT = 0x00000400,
  ROW_3 = 0x00000800,
  ROW_4_LEFT = 0x00001000,
  ROW_4_CENTER = 0x00002000,
  ROW_4_RIGHT = 0x00004000,
  ROW_4 = 0x00008000,
  WHOLE_CABIN = 0x80000000,
};

/**
 * Various Seats in the car.
 */
enum VehicleAreaSeat : int32_t {
    ROW_1_LEFT   = 0x0001,
    ROW_1_CENTER = 0x0002,
    ROW_1_RIGHT  = 0x0004,
    ROW_2_LEFT   = 0x0010,
    ROW_2_CENTER = 0x0020,
    ROW_2_RIGHT  = 0x0040,
    ROW_3_LEFT   = 0x0100,
    ROW_3_CENTER = 0x0200,
    ROW_3_RIGHT  = 0x0400
};

/**
 * Various windshields/windows in the car.
 */
enum VehicleAreaWindow : int32_t {
    FRONT_WINDSHIELD = 0x0001,
    REAR_WINDSHIELD = 0x0002,
    ROOF_TOP = 0x0004,
    ROW_1_LEFT = 0x0010,
    ROW_1_RIGHT = 0x0020,
    ROW_2_LEFT = 0x0100,
    ROW_2_RIGHT = 0x0200,
    ROW_3_LEFT = 0x1000,
    ROW_3_RIGHT = 0x2000,
};

enum VehicleAreaDoor : int32_t {
    ROW_1_LEFT = 0x00000001,
    ROW_1_RIGHT = 0x00000004,
    ROW_2_LEFT = 0x00000010,
    ROW_2_RIGHT = 0x00000040,
    ROW_3_LEFT = 0x00000100,
    ROW_3_RIGHT = 0x00000400,
    HOOD = 0x10000000,
    REAR = 0x20000000,
};

enum VehicleAreaMirror : int32_t {
    DRIVER_LEFT = 0x00000001,
    DRIVER_RIGHT = 0x00000002,
    DRIVER_CENTER = 0x00000004,
};

enum VehicleTurnSignal : int32_t {
    NONE = 0x00,
    RIGHT = 0x01,
    LEFT = 0x02,
    EMERGENCY = 0x04,
};

struct VehicleAreaConfig {
    /**
     * Area id is ignored for VehiclePropertyGroup:GLOBAL properties.
     */
    int32_t areaId;

    int32_t minInt32Value;
    int32_t maxInt32Value;

    int64_t minInt64Value;
    int64_t maxInt64Value;

    float minFloatValue;
    float maxFloatValue;
};

struct VehiclePropConfig {
    /** Property identifier */
    int32_t prop;

    /**
     * Defines if the property is read or write or both.
     */
    VehiclePropertyAccess access;

    /**
     * Defines the change mode of the property.
     */
    VehiclePropertyChangeMode changeMode;

    /**
     * Some of the properties may have associated areas (for example, some hvac
     * properties are associated with VehicleAreaZone), in these
     * cases the config may contain an ORed value for the associated areas.
     */
    int32_t supportedAreas;

    /**
     * Contains per-area configuration.
     */
    vec<VehicleAreaConfig> areaConfigs;

    /**
     * Configuration flags for this property.
     *
     * For example, it may store the number of presets that are stored by the
     * radio module.
     */
    int32_t configFlags;

    /** Contains additional configuration parameters */
    vec<int32_t> configArray;

    /**
     * Some properties may require additional information passed over this
     * string. Most properties do not need to set this.
     */
    string configString;

    /**
     * Min sample rate in Hz.
     * Must be defined for VehiclePropertyChangeMode::CONTINUOUS
     */
    float minSampleRate;

    /**
     * Must be defined for VehiclePropertyChangeMode::CONTINUOUS
     * Max sample rate in Hz.
     */
    float maxSampleRate;
};

/**
 * Encapsulates the property name and the associated value. It
 * is used across various API calls to set values, get values or to register for
 * events.
 */
struct VehiclePropValue {
    /** Property identifier */
    int32_t prop;

    /** Time is elapsed nanoseconds since boot */
    int64_t timestamp;

    /**
     * Area type(s) for non-global property it must be one of the value from
     * VehicleArea* enums or 0 for global properties.
     */
    int32_t areaId;

    /**
     * Contains value for a single property. Depending on property data type of
     * this property (VehiclePropetyType) one field of this structure must be filled in.
     */
    struct RawValue {
        /**
         * This is used for properties of types VehiclePropertyType#INT
         * and VehiclePropertyType#INT_VEC
         */
        vec<int32_t> int32Values;

        /**
         * This is used for properties of types VehiclePropertyType#FLOAT
         * and VehiclePropertyType#FLOAT_VEC
         */
        vec<float> floatValues;

        /** This is used for properties of type VehiclePropertyType#INT64 */
        vec<int64_t> int64Values;

        /** This is used for properties of type VehiclePropertyType#BYTES */
        vec<uint8_t> bytes;

        /** This is used for properties of type VehiclePropertyType#STRING */
        string stringValue;
    };

    RawValue value;
};

enum VehicleIgnitionState : int32_t {
    UNDEFINED = 0,

    /** Steering wheel is locked */
    LOCK = 1,

     /**
      * Steering wheel is not locked, engine and all accessories are OFF. If
      * car can be in LOCK and OFF state at the same time than HAL must report
      * LOCK state.
      */
    OFF,

    /**
     * Typically in this state accessories become available (e.g. radio).
     * Instrument cluster and engine are turned off
     */
    ACC,

    /**
     * Ignition is in state ON. Accessories and instrument cluster available,
     * engine might be running or ready to be started.
     */
    ON,

    /** Typically in this state engine is starting (cranking). */
    START
};


/**
 * Represent the operation where the current error has happened.
 */
enum VehiclePropertyOperation : int32_t {
    /**
     * Generic error to this property which is not tied to any operation.
     */
    GENERIC = 0,

    /**
     * Error happened while handling property set.
     */
    SET = 1,

    /**
     * Error happened while handling property get.
     */
    GET = 2,

    /**
     * Error happened while handling property subscription.
     */
    SUBSCRIBE = 3,
};


enum SubscribeFlags : int32_t {
  UNDEFINED = 0x0,

  /**
   * Subscribe to event that was originated in vehicle HAL
   * (most likely this event came from the vehicle itself).
   */
  HAL_EVENT = 0x1,

  /**
   * Use this flag to subscribe on events when IVehicle#set(...) was called by
   * vehicle HAL's client (e.g. Car Service).
   */
  SET_CALL = 0x2,

  DEFAULT = HAL_EVENT,
};

/**
 * Encapsulates information about subscription to vehicle property events.
 */
struct SubscribeOptions {
  /** Property to subscribe */
  int32_t propId;

  /**
   * Area ids - this must be a bit mask of areas to subscribe or 0 to subscribe
   * to all areas.
   */
  int32_t vehicleAreas;

  /**
   * Sample rate in Hz.
   *
   * Must be provided for properties with
   * VehiclePropertyChangeMode::CONTINUOUS. The value must be within
   * VehiclePropConfig#minSamplingRate .. VehiclePropConfig#maxSamplingRate
   * for a given property.
   * This value indicates how many updates per second client wants to receive.
   */
  float sampleRate;

  /** Flags that indicate what kind of events listen to. */
  SubscribeFlags flags;
};

/** Error codes used in vehicle HAL interface. */
enum StatusCode : int32_t {
  OK = 0,

  /** Try again. */
  TRY_AGAIN = 1,

  /** Invalid argument provided. */
  INVALID_ARG = 2,

  /**
   * This code must be returned when device that associated with the vehicle
   * property is not available. For example, when client tries to set HVAC
   * temperature when the whole HVAC unit is turned OFF.
   */
  NOT_AVAILABLE = 3,

  /** Access denied */
  ACCESS_DENIED = 4,

  /** Something unexpected has happened in Vehicle HAL */
  INTERNAL_ERROR = 5,
};

enum Wheel : int32_t {
    UNKNOWN = 0x0,

    LEFT_FRONT = 0x1,
    RIGHT_FRONT = 0x2,
    LEFT_REAR = 0x4,
    RIGHT_REAR = 0x8,
};
